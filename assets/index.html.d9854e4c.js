import{_ as e,z as l,A as i,a6 as a}from"./framework.fef63301.js";const r={},t=a('<h1 id="watch-api-的实现原理" tabindex="-1"><a class="header-anchor" href="#watch-api-的实现原理" aria-hidden="true">#</a> watch API 的实现原理</h1><h2 id="watch-api-用法" tabindex="-1"><a class="header-anchor" href="#watch-api-用法" aria-hidden="true">#</a> watch API 用法</h2><ul><li>watch API 可以监听一个 getter 函数 但是必须返回一个响应式对象 <ul><li>当响应式对象更新后 会执行对应的回调函数</li></ul></li><li>watch API 也可以直接监听一个响应式对象 <ul><li>当响应式对象更新后 会执行对应的回调函数</li></ul></li><li>watch API 可以直接监听多个响应式对象 数组的形式 任意一个响应式对象更新后 都会执行回调函数</li></ul><h2 id="watch-api-实现原理" tabindex="-1"><a class="header-anchor" href="#watch-api-实现原理" aria-hidden="true">#</a> watch API 实现原理</h2><ul><li>当监听对象或者函数发生变化的时候 监听器自动执行某个回调函数</li><li>watch 函数 拥有三个参数 <ul><li>source 表示监听的数据源</li><li>cb 表示数据变化后执行的回调函数</li><li>options 一些配置项</li></ul></li><li>watch 函数 内部调用了 doWatch 函数 <ul><li>调用前会在非生产环境判断第二个参数 cb 是不是 函数 不是发出警告</li><li>告诉用户 应该使用 watchEffect API</li></ul></li></ul><h3 id="标准化-source" tabindex="-1"><a class="header-anchor" href="#标准化-source" aria-hidden="true">#</a> 标准化 source</h3><ul><li>source 可以是 getter 函数 也可以是响应式对象 甚至是响应式对象数组 <ul><li>所以需要标准化 source</li></ul></li><li>source 标准化主要是根据 source 类型 生成标准化后的 getter 函数</li><li>如果 source 是 ref 对象 创建一个访问 source.value 的 getter 函数</li><li>如果 source是 reactive 对象 创建一个访问 source 的 getter 函数 设置 deep 为 true</li><li>如果 source 是一个函数 进一步判断第二个参数 cb 是否存在</li><li>如果 source 是一个数组 生成的 getter 函数内部通过 source.map 函数映射出有一个新的数组 会判断每个数组元素类型</li><li>如果 source 不满足上面条件 则在非生产环境下 发出警告 source 类型不合法</li><li>如果 deep 为 true 生成的 getter 函数被 traverse 函数包装一个</li></ul><h3 id="traverse" tabindex="-1"><a class="header-anchor" href="#traverse" aria-hidden="true">#</a> traverse</h3><ul><li>通过递归的方式访问 value 的每一个子属性</li><li>deep 属于 watcher 的一个配置选项</li></ul><h3 id="创建-job" tabindex="-1"><a class="header-anchor" href="#创建-job" aria-hidden="true">#</a> 创建 job</h3><ul><li>处理完 watch 第一个 参数 source 之后 开始处理 cb</li><li>cb 是一个回调函数 有三个参数 <ul><li>newValue : 新值</li><li>oldValue : 老值</li><li>onInvalidate : 注册的无效回调函数</li></ul></li><li>如果cb 存在 会先执行 effect.run 函数求的新值 实例就是执行前面创建的 getter 函数求新值</li><li>进行判断 如果 deep 深度或者 是 forckTrigger 强制更新 或者 新旧值发生了变化 <ul><li>执行回调函数 cb 传入参数 newValue oldValue</li><li>第一次执行的时候如果旧值没变化 就是 undefined</li><li>执行完回调函数 cb 后 再把 oldValue 更新成 newValue 为了做下一次的对比</li></ul></li></ul><h3 id="创建-scheduler" tabindex="-1"><a class="header-anchor" href="#创建-scheduler" aria-hidden="true">#</a> 创建 scheduler</h3><ul><li>scheduler 创建逻辑收到了第三个参数 options 中的 flush 的值影响 有三种状态 决定 watcher 回调函数执行时机 <ul><li>flush 是 sync 表示是一个同步的 watcher 数据变化同步执行 回调函数</li><li>flush 是 post 表示 回调函数通过 queuePostRenderEffect 方式在组件更新之后执行</li><li>flush 是 pre 表示 回调函数通过 queuePreFlushCb 方式在组件更新之前执行 如果组件没挂载 就在组件挂载之前通过一定的调度执行</li></ul></li></ul><h3 id="创建-effect" tabindex="-1"><a class="header-anchor" href="#创建-effect" aria-hidden="true">#</a> 创建 effect</h3><ul><li>wachter 内部都会 创建 effect 对象</li></ul><h4 id="effect-run-的执行" tabindex="-1"><a class="header-anchor" href="#effect-run-的执行" aria-hidden="true">#</a> effect.run 的执行</h4><ul><li>当回调函数 cb 存在 immediate 为 false 首次执行 effect.run 函数求 旧值</li><li>函数内部执行 getter 函数 访问响应式数据做依赖收集</li><li>此时的 activeEffect 就是 wacher 内部创建的 effect 对象 后续数据更新的时候 就可以触发 effect 对象的 scheduler 函数 执行 job 函数</li></ul><h4 id="配置了-immediate" tabindex="-1"><a class="header-anchor" href="#配置了-immediate" aria-hidden="true">#</a> 配置了 immediate</h4><ul><li>创建完 wacher 就会立刻直接 job 函数</li><li>oldValue 还是初始值 在 job 执行时候也会执行 effect.run</li><li>进而执行 getter 函数 做依赖收集 求的新值</li></ul><h3 id="返回销毁函数" tabindex="-1"><a class="header-anchor" href="#返回销毁函数" aria-hidden="true">#</a> 返回销毁函数</h3><ul><li>会返回一个 销毁函数 是 watch 执行后返回的函数 可以通过调用 来停止对数据的监听</li><li>销毁函数 内部会执行 effect.stop 函数 让 effect 失活 清理 effect 的相关依赖 <ul><li>就可以停止了对数据的监听</li><li>如果在组件注册的 watcher 也会移除组件 effects 对 effect 饮用</li></ul></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>watch 内部设计很巧妙 可以监听数据的变化 内部创建了 effect 对象</li><li>首次执行 effect.run 做依赖收集 然后在数据发生变化的时候</li><li>以某种调度方式执行回调函数</li></ul>',23),c=[t];function h(u,d){return l(),i("div",null,c)}const f=e(r,[["render",h],["__file","index.html.vue"]]);export{f as default};
