import{_ as e,z as t,A as i,a6 as a}from"./framework.fef63301.js";const r={},l=a('<h1 id="派发通知" tabindex="-1"><a class="header-anchor" href="#派发通知" aria-hidden="true">#</a> 派发通知</h1><ul><li>派发通知发生在数据更新阶段 用 proxy 劫持了数据对象 所以当响应式对象的属性值更新的时候 会执行 set 函数</li><li>set 函数是执行 createSetter 函数的返回值</li></ul><h2 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> set</h2><ul><li>set 函数 通过 Reflect.set 求值</li><li>通过 trigger 函数派发通知</li><li>并依据 key 是否存在与 target 上来确认通知类型 新增还是修改</li><li>最核心部分就是 执行 trigger 函数派发通知</li></ul><h2 id="trigger" tabindex="-1"><a class="header-anchor" href="#trigger" aria-hidden="true">#</a> trigger</h2><ul><li>主要做了 4件事 <ul><li>从 targetMap 中获取 target 对应的依赖集合 depsMap</li><li>创建运行的 effects 集合</li><li>根据 key 从 depsMap 中找到对应的 effects 添加到 effects 集合中</li><li>遍历 effects 执行相关的副作用函数</li></ul></li><li>因此每次一执行 trigger 函数 就是根据 target 和 key 从 targetMap 中找到所有相关的副作用函数 并遍历执行一次</li></ul><h2 id="effect" tabindex="-1"><a class="header-anchor" href="#effect" aria-hidden="true">#</a> effect</h2><ul><li>effect 内部通过执行 createReactiveEffect 函数创建一个新的 effect 函数 可以叫做 reactiveEffect 函数 并且给它添加一些新的属性</li><li>effect 函数支持传入一个配置参数 以支持更多的功能</li></ul><h2 id="reactiveeffect-副作用函数" tabindex="-1"><a class="header-anchor" href="#reactiveeffect-副作用函数" aria-hidden="true">#</a> reactiveEffect 副作用函数</h2><ul><li>reactiveEffect 函数就是响应式的副作用函数 当执行 trigger 过程派发通知的时候 执行 effect 的时候就是 reactiveEffect</li><li>只做了两件事 <ul><li>让全局的 reactiveEffect 指向本身</li><li>执行被包装的原始函数 fn</li></ul></li></ul>',10),c=[l];function f(s,d){return t(),i("div",null,c)}const n=e(r,[["render",f],["__file","index.html.vue"]]);export{n as default};
