import{_ as a,z as s,A as n,a6 as e}from"./framework.fef63301.js";const t={},r=e(`<h1 id="给-npm-script-传递参数和添加注释" tabindex="-1"><a class="header-anchor" href="#给-npm-script-传递参数和添加注释" aria-hidden="true">#</a> 给 npm script 传递参数和添加注释</h1><h2 id="给-npm-script-传递参数" tabindex="-1"><a class="header-anchor" href="#给-npm-script-传递参数" aria-hidden="true">#</a> 给 npm script 传递参数 --</h2><p>eslint 内置了代码风格自动修复模式，只需给它传入 --fix 参数即可，在 scripts 中声明检查代码命令的同时你可能也需要声明修复代码的命令，面对这种需求，大多数同学可能会忍不住复制粘贴，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token string-property property">&quot;lint:js:fix&quot;</span><span class="token operator">:</span> <span class="token string">&quot;eslint *.js --fix&quot;</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 lint:js 命令比较短的时候复制粘贴的方法简单粗暴有效，但是当 lint:js 命令变的很长之后，难免后续会有人改了 lint:js 而忘记修改 lint:js:fix（别问我为啥，我就是踩着坑过来的），更健壮的做法是，在运行 npm script 时给定额外的参数，代码修改如下</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token string-property property">&quot;lint:js:fix&quot;</span><span class="token operator">:</span> <span class="token string">&quot;npm run lint:js -- --fix&quot;</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要格外注意 --fix 参数前面的 -- 分隔符，意指要给 npm run lint:js 实际指向的命令传递额外的参数。</p><h2 id="给-npm-script-添加注释" tabindex="-1"><a class="header-anchor" href="#给-npm-script-添加注释" aria-hidden="true">#</a> 给 npm script 添加注释</h2><h3 id="第一种" tabindex="-1"><a class="header-anchor" href="#第一种" aria-hidden="true">#</a> 第一种</h3><p>package.json 中可以增加 // 为键的值，注释就可以写在对应的值里面，npm 会忽略这种键，比如，我们想要给 test 命令添加注释，按如下方式添加</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">+</span>    <span class="token string">&quot;//&quot;</span><span class="token operator">:</span> <span class="token string">&quot;运行所有代码检查和单元测试&quot;</span><span class="token punctuation">,</span>
     <span class="token string-property property">&quot;test&quot;</span><span class="token operator">:</span> <span class="token string">&quot;npm-run-all --parallel lint:* mocha&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式的明显不足是，npm run 列出来的命令列表不能把注释和实际命令对应上，如果你声明了多个，npm run 只会列出最后那个，如下图：</p><h3 id="第二种" tabindex="-1"><a class="header-anchor" href="#第二种" aria-hidden="true">#</a> 第二种</h3><p>直接在 script 声明中做手脚，因为命令的本质是 shell 命令（适用于 linux 平台），我们可以在命令前面加上注释，具体做法如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token string-property property">&quot;test&quot;</span><span class="token operator">:</span> <span class="token string">&quot;# 运行所有代码检查和单元测试 \\n    npm-run-all --parallel lint:* mocha&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意注释后面的换行符 \\n 和多余的空格，换行符是用于将注释和命令分隔开，这样命令就相当于微型的 shell 脚本，多余的空格是为了控制缩进，也可以用制表符 \\t 替代。这种做法能让 npm run 列出来的命令更美观，但是 scripts 声明阅读起来不那么整齐美观。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/27/15ffa72c247900f5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片"></p><h2 id="调整-npm-script-运行时日志输出" tabindex="-1"><a class="header-anchor" href="#调整-npm-script-运行时日志输出" aria-hidden="true">#</a> 调整 npm script 运行时日志输出</h2><p>在运行 npm script 出现问题时你需要有能力去调试它，某些情况下你需要让 npm script 以静默的方式运行，这类需求可通过控制运行时日志输出级别来实现。</p><p>日志级别控制参数有好几个，简单举例如下：</p><h3 id="默认日志输出级别" tabindex="-1"><a class="header-anchor" href="#默认日志输出级别" aria-hidden="true">#</a> 默认日志输出级别</h3><p>即不加任何日志控制参数得到的输出，可能是你最常用的，能看到执行的命令、命令执行的结果。</p><h3 id="显示尽可能少的有用信息" tabindex="-1"><a class="header-anchor" href="#显示尽可能少的有用信息" aria-hidden="true">#</a> 显示尽可能少的有用信息</h3><p>结合其他工具调用 npm script 的时候比较有用，需要使用 --loglevel silent，或者 --silent，或者更简单的 -s 来控制，这个日志级别的输出实例如下（只有命令本身的输出，读起来非常的简洁）：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/27/15ffa73279c8a9e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片"> 如果执行各种 lint script 的时候启用了 -s 配置，代码都符合规范的话，你不会看到任何输出，这就是没有消息是最好的消息的由来，哈哈！</p><h3 id="显示尽可能多的运行时状态" tabindex="-1"><a class="header-anchor" href="#显示尽可能多的运行时状态" aria-hidden="true">#</a> 显示尽可能多的运行时状态</h3><p>排查脚本问题的时候比较有用，需要使用 --loglevel verbose，或者 --verbose，或者更简单的 -d 来控制，这个日志级别的输出实例如下（详细打印出了每个步骤的参数、返回值，下面的截图只是部分）：</p>`,26),p=[r];function i(c,o){return s(),n("div",null,p)}const d=a(t,[["render",i],["__file","index.html.vue"]]);export{d as default};
