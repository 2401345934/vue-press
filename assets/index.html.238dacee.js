import{_ as e,z as i,A as l,a6 as a}from"./framework.fef63301.js";const t={},r=a('<h1 id="响应式实现的优化-vue3-2-版本" tabindex="-1"><a class="header-anchor" href="#响应式实现的优化-vue3-2-版本" aria-hidden="true">#</a> 响应式实现的优化 Vue3.2 版本</h1><h2 id="依赖收集的优化" tabindex="-1"><a class="header-anchor" href="#依赖收集的优化" aria-hidden="true">#</a> 依赖收集的优化</h2><ul><li>之前每次执行副作用函数 都需要先执行 cleanup 清除依赖 然后在副作用函数执行的过程重新收集依赖 <ul><li>过程涉及大量的对集合 set 对添加和删除操作 存在优化空间</li></ul></li><li>为了减少集合的添加和删除操作 标识了每个依赖集合的状态 比如：新收集的 还是收集过的</li></ul><h2 id="设计的全局变量" tabindex="-1"><a class="header-anchor" href="#设计的全局变量" aria-hidden="true">#</a> 设计的全局变量</h2><ul><li>effectTrackDepth <ul><li>执行 effect函数的深度</li></ul></li><li>trackOpBit <ul><li>标识依赖的收集状态</li></ul></li><li>maxMarkerBits <ul><li>最大标记的位数</li></ul></li><li>effectTrackDepth</li></ul><h2 id="effect-函数实现优化" tabindex="-1"><a class="header-anchor" href="#effect-函数实现优化" aria-hidden="true">#</a> effect 函数实现优化</h2><ul><li>内部使用 ReactiveEffect 类创建了 _effect实例 并且让函数返回 runner 指向 ReactiveEffect类的 run 函数</li><li>也就是说在执行副作用函数 effect 的时候 实际执行的就是 run 函数</li><li>收集的依赖也从 effect 函数 变成了 _effect 对象</li><li>当 run 函数执行的时候 cleanup 函数 不是再默认执行 会通过 包装好的函数 fn 执行前 先执行 trackOpBit = 1 &lt;&lt; ++effectTrackDepth 记录 trackOpBit</li><li>然后看递归的深度是否超过了 maxMarkerBirts 如果超过 执行老的 cleanup 逻辑</li><li>没超过 执行 initDepMarkers 给依赖打标记</li></ul><h2 id="优化结果" tabindex="-1"><a class="header-anchor" href="#优化结果" aria-hidden="true">#</a> 优化结果</h2><ul><li>相比于优化前 每次执行 effect 函数 都需要清空依赖 添加依赖的过程</li><li>优化后 每次执行 effect 函数 标记依赖的状态 不会重复收集已经收集的依赖 执行 effect 函数之后 还会移除已被收集但在新一轮没有被收集的依赖</li><li>优化了减少对于 dep 依赖集合的操作 自然的性能提高了</li></ul><h2 id="trackopbit-的设计" tabindex="-1"><a class="header-anchor" href="#trackopbit-的设计" aria-hidden="true">#</a> trackOpBit 的设计</h2><ul><li>标记依赖的 trackOpBit 每次执行计算的时候采用了 左移运算符 trackOpBit = 1 &lt;&lt; ++effectTrackDepth 并且在赋值 的时候做了运算</li><li>为什么要这样 ？ <ul><li>因为 effect 执行会有递归的情况 可以通过这种方式记下每个层级的依赖标记情况</li></ul></li><li>在判断 dep 是否已经收集了当前层的依赖 使用了 wasTracked 函数 <ul><li>内部通过 与运算 的结果是否大于 0 来判断当前层级依赖是否已经收集过了</li></ul></li></ul>',11),c=[r];function f(h,n){return i(),l("div",null,c)}const d=e(t,[["render",f],["__file","index.html.vue"]]);export{d as default};
