import{_ as n,z as s,A as a,a6 as e}from"./framework.fef63301.js";const t="/vue-press/assets/life-cycle.c73822ac.png",o={},p=e(`<h1 id="组件的生命周期" tabindex="-1"><a class="header-anchor" href="#组件的生命周期" aria-hidden="true">#</a> 组件的生命周期</h1><ul><li>setup 函数替代了 vue2 中的 beforeCreate created 钩子函数</li></ul><h2 id="vue3-钩子函数-vs-vue2-钩子函数" tabindex="-1"><a class="header-anchor" href="#vue3-钩子函数-vs-vue2-钩子函数" aria-hidden="true">#</a> vue3 钩子函数 vs vue2 钩子函数</h2><ul><li>setup =&gt; beforeCreate</li><li>setup =&gt; created</li><li>onBeforeMount =&gt; beforeMount</li><li>onMounted =&gt; mounted</li><li>onBeforeUpdate =&gt; beforeUpdate</li><li>onUpdated =&gt; updated</li><li>onBeforeUnmount =&gt; beforeDestroy</li><li>onUnmounted =&gt; destroyed</li><li>onActivated =&gt; activated</li><li>onDeactivated =&gt; deactivated</li><li>onErrorCaptured =&gt; errorCaptured</li><li>onRenderTracked =&gt; renderTracked</li><li>onRenderTriggered =&gt; renderTtiggered</li></ul><h2 id="注册钩子函数" tabindex="-1"><a class="header-anchor" href="#注册钩子函数" aria-hidden="true">#</a> 注册钩子函数</h2><ul><li>都是通过 createHook 注册</li><li>会返回一个函数 内部通过 injectHook 注册钩子函数</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">injectHook</span><span class="token punctuation">(</span>
  type<span class="token operator">:</span> LifecycleHooks<span class="token punctuation">,</span>
  hook<span class="token operator">:</span> <span class="token builtin">Function</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> __weh<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">Function</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  target<span class="token operator">:</span> ComponentInternalInstance <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> currentInstance<span class="token punctuation">,</span>
  prepend<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Function</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> hooks <span class="token operator">=</span> target<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>target<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// cache the error handling wrapper for injected hooks so the same hook</span>
    <span class="token comment">// can be properly deduped by the scheduler. &quot;__weh&quot; stands for &quot;with error</span>
    <span class="token comment">// handling&quot;.</span>
    <span class="token keyword">const</span> wrappedHook <span class="token operator">=</span>
      hook<span class="token punctuation">.</span>__weh <span class="token operator">||</span>
      <span class="token punctuation">(</span>hook<span class="token punctuation">.</span><span class="token function-variable function">__weh</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>isUnmounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// disable tracking inside all lifecycle hooks</span>
        <span class="token comment">// since they can potentially be called inside effects.</span>
        <span class="token function">pauseTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// Set currentInstance during hook invocation.</span>
        <span class="token comment">// This assumes the hook does not synchronously trigger other hooks, which</span>
        <span class="token comment">// can only be false when the user does something really funky.</span>
        <span class="token function">setCurrentInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
        <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">callWithAsyncErrorHandling</span><span class="token punctuation">(</span>hook<span class="token punctuation">,</span> target<span class="token punctuation">,</span> type<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token function">unsetCurrentInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token function">resetTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prepend<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      hooks<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>wrappedHook<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      hooks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>wrappedHook<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> wrappedHook
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> apiName <span class="token operator">=</span> <span class="token function">toHandlerKey</span><span class="token punctuation">(</span>ErrorTypeStrings<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex"> hook$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>apiName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is called when there is no active component instance to be </span><span class="token template-punctuation string">\`</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">associated with. </span><span class="token template-punctuation string">\`</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Lifecycle injection APIs can only be used during execution of setup().</span><span class="token template-punctuation string">\`</span></span> <span class="token operator">+</span>
        <span class="token punctuation">(</span>__FEATURE_SUSPENSE__
          <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string"> If you are using async setup(), make sure to register lifecycle </span><span class="token template-punctuation string">\`</span></span> <span class="token operator">+</span>
            <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">hooks before the first await statement.</span><span class="token template-punctuation string">\`</span></span>
          <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="injecthook" tabindex="-1"><a class="header-anchor" href="#injecthook" aria-hidden="true">#</a> injectHook</h2><ul><li>对用户注册的钩子函数 hook 做了一层封装</li><li>然后添加到一个数组中 并把数组保存到当前组件的实例的 target 上</li><li>不同类型的钩子函数会被保存到组件实例的不同属性上</li></ul><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> createHook <span class="token operator">=</span>
  <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>lifecycle<span class="token operator">:</span> LifecycleHooks<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token punctuation">(</span>hook<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> target<span class="token operator">:</span> ComponentInternalInstance <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> currentInstance<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token comment">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span>
    <span class="token punctuation">(</span><span class="token operator">!</span>isInSSRComponentSetup <span class="token operator">||</span> lifecycle <span class="token operator">===</span> LifecycleHooks<span class="token punctuation">.</span><span class="token constant">SERVER_PREFETCH</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token function">injectHook</span><span class="token punctuation">(</span>lifecycle<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">hook</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="onbeforemount-和-onmounted" tabindex="-1"><a class="header-anchor" href="#onbeforemount-和-onmounted" aria-hidden="true">#</a> onBeforeMount 和 onMounted</h2><ul><li>onBeforeMount 注册的 beforeMount 钩子函数 会在组件挂载之前执行</li><li>onMounted 注册的 mounted 钩子函数会在组件挂载之后执行</li><li>在执行 patch 挂载组件之前 会检测组件实例是否有已注册的beforeMount 钩子函数 bm <ul><li>如果有 则通过 invokeArrayFns 执行 这里是一个数组 会遍历执行 因为用户可以注册多个 beforemount 函数</li></ul></li><li>在执行 patch 挂载组件之后 会检测组件实例是否有已注册的 mounted 钩子函数 m <ul><li>如果有 则通过 quenePostRenderEffect 执行</li></ul></li></ul><h2 id="onbeforeupdate-和-onupdated" tabindex="-1"><a class="header-anchor" href="#onbeforeupdate-和-onupdated" aria-hidden="true">#</a> onBeforeUpdate 和 onUpdated</h2><ul><li>onBeforeUpdate 注册的 beforeUpdate 钩子函数 会在组件更新之前执行</li><li>onUpdated 注册的 updated 钩子函数会在组件更新之后执行</li><li>在执行 patch 更新组件之前 会检测组件实例是否有已注册的 beforeUpdate 钩子函数 bu <ul><li>如果有 则通过 invokeArrayFns 执行</li></ul></li><li>在执行 patch 更新组件之后 会检测组件实例是否有已注册的 updated 钩子函数 u <ul><li>如果有 则通过 quenePostRenderEffect 执行</li></ul></li><li>父组件的更新不一定会导致子组件的更新 因为 vue js 更新的颗粒度是 组件级别的</li></ul><h2 id="onbeforeunmount-和-onunmounted" tabindex="-1"><a class="header-anchor" href="#onbeforeunmount-和-onunmounted" aria-hidden="true">#</a> onBeforeUnmount 和 onUnmounted</h2><ul><li>onBeforeUnmount 注册的 beforeUnMount 钩子函数 会在组件销毁之前执行</li><li>onUnmounted 注册的 unmounted 钩子函数会在组件销毁之后执行</li><li>组件的销毁整体逻辑 其实就是 清理组件实例上绑定的 effects 副作用函数 和注册的副作用渲染函数 update 并且调用 unmount 销毁子树</li><li>unmount 会遍历子树 通过递归的方式 销毁子节点 <ul><li>遇到组件节点执行 unmountComponent</li><li>遇到普通元素 删除 DOM元素</li><li>组件的销毁过程和渲染过程类似 都是递归</li></ul></li><li>在组件销毁之前 会检测组件实例是否有已注册的 beforeUnMount 钩子函数 bum <ul><li>如果有 则通过 invokeArrayFns 执行</li></ul></li><li>在组件销毁之后 会检测组件实例是否有已注册的 unmounted 钩子函数 um <ul><li>如果有 则通过 quenePostRenderEffect 把它 推入数组</li><li>组件的销毁是组件更新的一个分支逻辑 也是在 nextTick 之后执行的</li><li>会等待当前任务执行之后 在同一个事件循环内执行所有的 umounted 钩子函数</li></ul></li></ul><h2 id="onerrorcaptured" tabindex="-1"><a class="header-anchor" href="#onerrorcaptured" aria-hidden="true">#</a> onErrorCaptured</h2><ul><li>是在 调用 handleError 函数 中执行的 钩子函数</li><li>handleError 会从当前报错的组件的父组件实例开始 尝试查找 已注册的 errorCaptured 钩子函数</li><li>如果找到了 遍历执行判断 errorCaptured 钩子函数是否返回值是 true 若是 则说明这个错误已经得到正确的处理 结束遍历</li><li>如果找不到 会继续遍历 在遍历完当前组件实例的 errorCaptured 钩子函数 如果还没有找到 就会找它的父组件实例 直到查找完毕</li><li>如果整条链路都没处理 errorCaptured 钩子函数 通过 logError 向通知台输出 未处理的错误 <ul><li>开发环境 会导致程序崩溃 为了给开发者足够强的提醒</li><li>errorCaptured 本质是捕获来自 子孙组件的错误 返回 true 就是 阻止错误向上传播</li></ul></li><li>可以在根组件 注册一个 errorCaptured 钩子函数 用于捕获所有子孙组件的错误 根据错误类型 上报错误信息 统计</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>vue js 组件的生命周期包括 创建 更新 销毁等阶段 在此我们可以注入一些生命周期钩子函数执行自己的代码逻辑 <img src="`+t+'" alt="图片"></li></ul>',20),l=[p];function i(c,u){return s(),a("div",null,l)}const d=n(o,[["render",i],["__file","index.html.vue"]]);export{d as default};
