import{_ as t,z as a,A as c,X as n,C as e,T as i,a6 as o,Q as p}from"./framework.fef63301.js";const d={},r=o(`<h1 id="http请求头" tabindex="-1"><a class="header-anchor" href="#http请求头" aria-hidden="true">#</a> HTTP请求头</h1><h3 id="_1-1-场景" tabindex="-1"><a class="header-anchor" href="#_1-1-场景" aria-hidden="true">#</a> 1.1 场景</h3><p>如果你有了解过 <code>Content-Disposition</code> 这个 <code>Response Header</code>，那你一定知道，只需要响应头上增加一行，问题就能迎刃而解。</p><h3 id="_1-2-介绍" tabindex="-1"><a class="header-anchor" href="#_1-2-介绍" aria-hidden="true">#</a> 1.2 介绍</h3><p><strong><code>Content-Disposition</code></strong>：这个响应头可以决定内容是 <strong>预览</strong> 还是 <strong>下载</strong>。</p><p>它支持三种格式的值：</p><ol><li><code>Content-Disposition: inline</code><br> 此时，消息体会以页面的一部分或者整个页面的形式展示。（预览）</li><li><code>Content-Disposition: attachment</code><br> 消息体应该被下载，默认文件名和 <code>url</code> 格式有关。</li><li><code>Content-Disposition: attachment; filename=&quot;filename.jpg&quot;</code><br> 消息体应该被下载，默认文件名可指定。</li></ol><blockquote><p>注：如果需要预览，需要配合适当的 <code>Content-Type</code> 食用；</p></blockquote><h3 id="_1-3-示例" tabindex="-1"><a class="header-anchor" href="#_1-3-示例" aria-hidden="true">#</a> 1.3 示例</h3><p>为此，我特意写了一个 <code>express</code> 小示例。</p><p>大抵是在 <code>express</code> 应用下写了三个路由，如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;摸鱼的春哥&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">blogUrl</span><span class="token operator">:</span> <span class="token string">&quot;https://juejin.cn/user/1714893870865303&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">contentDispositionInline</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&#39;Content-Disposition&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;inline&#39;</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">contentDispositionFilename</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&#39;Content-Disposition&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;attachment; filename=&quot;chunge.json&quot;&#39;</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">contentDispositionNoFilename</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&#39;Content-Disposition&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;attachment&#39;</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我分别访问三个路由，效果差异：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b92606d69564a6cb5fd1bdf0c005370~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><h2 id="二、项目升级了-需要客户-清空缓存" tabindex="-1"><a class="header-anchor" href="#二、项目升级了-需要客户-清空缓存" aria-hidden="true">#</a> 二、项目升级了，需要客户 <strong>清空缓存</strong> ？</h2><h3 id="_2-1-场景" tabindex="-1"><a class="header-anchor" href="#_2-1-场景" aria-hidden="true">#</a> 2.1 场景</h3><p>实施：“客户反馈<code>Bug</code> 还是没修复。”<br> 你：“哥，真修复了，要不你让客户清一下缓存？”<br> 实施：“啊？客户说他不会清……”<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27dff5bd3a2546168adcb1d6651dcd91~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>永远不要期望你的客户会进行 <strong>“那些研发才懂”</strong> 的操作。也不要把你的问题，归因到 <strong>浏览器缓存</strong> 上。</p><p><strong>浏览器缓存</strong> 是被发明出来优化用户体验的，并不是被发明出来阻碍用户的。</p><p>因此，理解如何使用 <code>Cache-Control</code> 这个响应头，是前端的必知技能。</p><h3 id="_2-2-介绍" tabindex="-1"><a class="header-anchor" href="#_2-2-介绍" aria-hidden="true">#</a> 2.2 介绍</h3><p><strong><code>Cache-Control</code></strong>：用来指定缓存机制。</p><p>缓存，作为前端八股文必考知识，相信大家已经耳熟能详。 常见的 <strong><code>Cache-Control</code></strong> 属性如下：</p><table><thead><tr><th>Response Header属性</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>cache-control</td><td>no-store</td><td>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</td></tr><tr><td>cache-control</td><td>public</td><td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）</td></tr><tr><td>cache-control</td><td>private</td><td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。</td></tr><tr><td>cache-control</td><td>max-age=&lt;1000&gt;</td><td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td></tr></tbody></table>`,24),l=o("<li>不缓存<br> 不缓存是最容易理解，每一次请求都会从服务端重新获取，不进行任何缓存。<br> 此策略只需要赋予 <code>Cache-Control: no-store</code> 响应头即可。</li><li>强缓存<br> 有些资源文件，几乎不会发生变化（比如已经 <code>hash化命名的文件</code>），则可以直接从本地缓存获取，这就是所谓的 <strong>强缓存</strong> ;<br> 通过 <code>cache-control: public/private</code> 或者 <code>cache-control: max-age=&lt;1000&gt;</code> 都可以指定机制为强缓存。</li>",2),u=n("br",null,null,-1),k=n("strong",null,"简单粗暴地",-1),h=n("br",null,null,-1),b=n("code",null,"hash",-1),g=n("strong",null,"资源是否发生过变化",-1),m=n("br",null,null,-1),v={href:"https://juejin.cn/post/7030781324650610695",title:"https://juejin.cn/post/7030781324650610695",target:"_blank",rel:"noopener noreferrer"},f=o('<h3 id="_2-3-实际生产如何运用" tabindex="-1"><a class="header-anchor" href="#_2-3-实际生产如何运用" aria-hidden="true">#</a> 2.3 实际生产如何运用？</h3><ul><li>凡是名称带有 <code>hash</code> 值的资源，一律可以强缓存。<br> （毕竟内容一旦有变化，名称的<code>hash</code> 也跟着变了）</li><li>凡是通过 <code>cdn</code> 引入的第三方库，均建议携带版本信息，这样也可以强缓存。<br> （比如 <code>/xx/xx/jquery.min.js</code> 切换为 <code>jquery@3.6.0/dist/jquery.min.js</code>）</li><li>凡是 <code>html</code>、<code>ico</code> 这类命名固定的文件，建议一律 <strong>不缓存</strong> 或者 <strong>协商缓存</strong>。</li></ul><h2 id="三、我的-cookie-不可能这么可爱" tabindex="-1"><a class="header-anchor" href="#三、我的-cookie-不可能这么可爱" aria-hidden="true">#</a> 三、我的 <code>Cookie</code> 不可能这么可爱</h2><h3 id="_3-1-场景" tabindex="-1"><a class="header-anchor" href="#_3-1-场景" aria-hidden="true">#</a> 3.1 场景</h3><blockquote><p>&quot;春哥春哥，为啥我登录成功了，请求还是 <code>401</code> ？&quot;</p></blockquote><blockquote><p>&quot;春哥春哥，为啥我存进 <code>cookie</code> 的值取不到？&quot;</p></blockquote><blockquote><p>&quot;春哥春哥，这破 <code>cookie</code> 是不是坏了，浏览器里看明明有值，为啥我访问不了？&quot;</p></blockquote><p>我：“兄弟，你有了解过一个叫 <code>set-cookie</code> 的响应头吗？”</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48bf9bf38d94486498a7b33afd7d7766~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"> 是它！是它！就是它！关于 <code>cookie</code> 的各种异常，全靠它!</p><h3 id="_3-2-介绍" tabindex="-1"><a class="header-anchor" href="#_3-2-介绍" aria-hidden="true">#</a> 3.2 介绍</h3><p><code>Cookie</code> 曾经是 <code>Web</code> 开发无法绕开的一道门槛，而现在它的存在感越来越弱，但海量的存量项目并不会因为技术的趋势而消失，它们依然很有价值，依然需要维护。</p><p>而 <code>set-cookie</code> 响应头正是 <code>Cookie</code> 体系中最为核心的 <strong>第一主角</strong>。</p><p><strong><code>Set-Cookie</code></strong>: 是一个响应头，服务端赋值，让浏览器端产生 <code>Cookie</code>，并限定 <code>Cookie</code> 的各种特性。</p><p>这些特性就包括：</p><ul><li>过期时限；<code>Expires=&lt;date&gt;</code></li><li>存活周期；<code>Max-Age=&lt;number&gt;</code><br> 在 cookie 失效之前需要经过的秒数。<code>0</code> 或 <code>-1</code> 直接失效；此属性的优先级高于 <code>Expires</code>。</li><li>域名；<code>Domain=&lt;domain-value&gt;</code><br> 指定 <code>cookie</code> 只能在什么域下生成；（允许通配，这个属性主要出于安全性）</li><li>路径；<code>Path=&lt;path-value&gt;</code><br> 比 <code>Domain</code> 更为细致的控制策略，甚至指定了 <code>xx</code> 路径下才能发送 <code>Cookie</code>。</li><li>只在 <code>Https</code> 产生；<code>Secure</code><br> 如果 <code>set-cookie</code> 头中有 <code>Secure</code> 属性，那么浏览器只会在 <code>Https</code> 环境产生和发送 <code>Cookie</code>。</li><li>禁用 <code>js</code> 操作 <code>API</code>；<code>HttpOnly</code><br> 如果 <code>set-cookie</code> 头中有 <code>HttpOnly</code> 属性，那么 <code>Cookie</code> 属性的生成、读写、发送就只能由浏览器通过 &quot;响应头&quot; 控制了，不在允许前端通过 <code>js</code> 操作 <code>Cookie</code>。</li><li>是否允许跨域携带；<code>SameSite=&lt;samesite-value&gt;</code><br> 支持属性包括 <code>Strict</code>、<code>Lax</code>、<code>None</code>，分别表示： <ul><li><code>Strict</code>: 完全不能跨域携带；</li><li><code>Lax</code>: 只允许从外站导航到源站时携带 <code>Cookie</code></li><li><code>None</code>：跨域也行，不限制。</li></ul></li></ul><h3 id="_3-3-开发常见问题分析" tabindex="-1"><a class="header-anchor" href="#_3-3-开发常见问题分析" aria-hidden="true">#</a> 3.3 开发常见问题分析</h3><ul><li><p>为啥你登录成功了，请求还是 <code>401</code>？</p><p>早期非常多的项目，使用 <code>Cookie</code> 作为用户身份识别的手段，比如 <code>Spring MVC</code> 项目就是通过给 <code>Cookie</code> 一个 <code>JSeesionId</code> 的值作为识别，判断你是否出于当前会话。</p><p>而 &quot;登录了，却还 <code>401</code>&quot; 这个现象，如果服务端没有问题的话，多半是 <strong>浏览器其实并未存储Cookie</strong>。</p><p>换个说法，你每次发起请求，服务端都认为你是一次 <strong>新的会话</strong>，和上一次 <strong>登录的你</strong> 并非同一人。</p><p>如果你正处于 <code>http</code> 环境，那你可能需要暂时移除 <code>Secure</code> 属性。</p></li><li><p>存不进、取不出？<br> 先确认 <strong>是否有域的限制</strong>、<strong>是否有路径的限制</strong>、<strong>是否有 <code>HttpOnly</code></strong>?<br> 逐一排查下来，问题不难解决。</p></li></ul>',17);function _(x,C){const s=p("ExternalLinkIcon");return a(),c("div",null,[r,n("ul",null,[l,n("li",null,[e("协商缓存"),u,e(" 这是一种更为复杂缓存机制，无法再通过响应头 "),k,e(" 指定实现，而是需要前后端协作配合。"),h,e(" 简单来说，每次请求资源前前端会写代前一次的响应 "),b,e("，问询服务端 "),g,e("，从而达到准确缓存的效果。"),m,e(" 本文不赘述，如果有兴趣，可以参考此文："),n("a",v,[e("juejin.cn/post/703078…"),i(s)])])]),f])}const j=t(d,[["render",_],["__file","index.html.vue"]]);export{j as default};
